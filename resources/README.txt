Easy Animator (Part 3)

Emily Colladay, Jennifer Fehring, Joseph Maydwell

VIEW / MODEL / CONTROLLER

In this iteration of our easy animator, we primarily focused on implementing two new classes and one new interface: EditorView, Controller, and IEditorView. For the most part, our model remained unchanged and our GraphicalView, TextView, and SVGView remained completely unchanged. 

Changes to our model included the addition of several methods, as well as the removal of one method that ended up having no use - the sortByAppearanceTime method. A method called getFinalTick was implemented that determines the very last tick in an animation. This method was needed in the controller to reset the animation and loop over the it until the final tick is reached if the loop toggle box is checked. Another method, resetAnimation, was implemented to reset all the shapes in the animationsCopy hash map to their original state, which had previously been stored in the animation hash map. Finally, a get animation method was implemented so there was some easy way to access the animation hash map. 

Controller - the controller class takes in the view and the model and coordinates changes in the animation based on user input. First, a timer is initialized, followed by a method to set up all the action listeners. Within the setActionListeners method, all the action listener classes for pause, start, speed up, speed down, restart, and toggle looping, are set up, and action performed methods for each button are set up to execute the desired change. For example, in the PauseButtonListener class contained within the setActionListeners method, when a pause event is triggered the actionPerformed method stops the timer. Similarly, the PlayButtonListener class registers play button clicks and starts the timer. The SpeedUp class listens for speed up button events, and decreases the delay by a preset value. These preset values are adjusted based on initial user input. Conversely, the SpeedDown class registers speed down events and responds by increasing animation delay by a preset value. The LoopButtonListener checks whether the box is checked or not, and if it is clicked, the boolean for loopToggle switches to the opposite of what it was. When the loopToggle is checked, the timer is reset to 0 by the Timer class. Finally, the RestartButtonListener registers restart events and responds by reverting the model to its original state, then updating the frame in the view. 

IEditorView - This interface contains method signatures for all methods included in all classes that implement IEditorView. 

EditorView - To add the new functionality required for this part of the project, we decided to create a completely new class, EditorView, which extends JFrame and implements its own interface (IEditorView). It is a more complex version of part 2's GraphicalViewFrame, as it utilizes multiple panels to create the visual presented to the user. Like GraphicalViewFrame, it does include an animationPanel, which houses the information of the model, with its shapes and transformations. It also includes a scrollPanel so that the user may resize and scroll to whichever part of the view that they would like. This uses the JScrollPane functionality. As in part2, we have used the main method to test its functionality while working on its various features.
In addition, it also includes various buttons that change the course of the animation - play, pause, restart, speed up, speed down, and loop (the latter being a checkbox type). These are all contained in a separate JPanel, barPanel, which has a grid type layout located at the bottom of the frame. Each button has different functionality, implemented by adding getter methods. These getter methods are used in the controller to either pause the animation, continue it, restart from the beginning, speed it up or down, or loop the animation when it is finished until the user exits. Thus, the user can enjoy more features that make this view feel like a video that they have more control over. 
